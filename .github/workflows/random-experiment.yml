name: ðŸŽ² Random Experiment

on:
  schedule:
    # Weekly on Sunday at 4 AM JST (Saturday 7 PM UTC)
    - cron: '0 19 * * 6'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  experiment:
    runs-on: ubuntu-latest
    name: Apply Random Experimental Improvement
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'
      
      - name: Select and apply random experiment
        run: |
          node -e "
          const fs = require('fs');
          
          // å®Ÿé¨“ã‚«ã‚¿ãƒ­ã‚°
          const experiments = [
            {
              name: 'add-performance-monitor',
              description: 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚’è¿½åŠ ',
              apply: () => {
                const main = fs.readFileSync('main.js', 'utf8');
                if (main.includes('Performance Monitor')) return false;
                
                const code = \`
    // Performance Monitor (Auto-added)
    if (Game.time % 100 === 0) {
        const used = JSON.stringify(Memory).length;
        const limit = 2048 * 1024;
        console.log(\\\`ðŸ“Š Memory: \\\${(used/1024).toFixed(2)}KB / \\\${(limit/1024).toFixed(2)}KB (\\\${(used/limit*100).toFixed(1)}%)\\\`);
        console.log(\\\`âš¡ CPU: \\\${Game.cpu.getUsed().toFixed(2)} / \\\${Game.cpu.limit}\\\`);
    }
\`;
                const updated = main.replace(/(module\.exports\.loop\s*=\s*function\s*\(\s*\)\s*{)/, \`\$1\${code}\`);
                fs.writeFileSync('main.js', updated);
                return true;
              }
            },
            {
              name: 'optimize-pathfinding-cache',
              description: 'çµŒè·¯æŽ¢ç´¢ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ€é©åŒ–',
              apply: () => {
                const main = fs.readFileSync('main.js', 'utf8');
                if (main.includes('pathCache')) return false;
                
                const code = \`
    // Path Cache Cleanup (Auto-added)
    if (!Memory.pathCache) Memory.pathCache = {};
    if (Game.time % 1000 === 0) {
        const oldPaths = Object.keys(Memory.pathCache)
            .filter(key => Memory.pathCache[key].tick < Game.time - 1000);
        oldPaths.forEach(key => delete Memory.pathCache[key]);
        if (oldPaths.length > 0) {
            console.log(\\\`ðŸ§¼ Cleaned \\\${oldPaths.length} old cached paths\\\`);
        }
    }
\`;
                const updated = main.replace(/(module\.exports\.loop\s*=\s*function\s*\(\s*\)\s*{)/, \`\$1\${code}\`);
                fs.writeFileSync('main.js', updated);
                return true;
              }
            },
            {
              name: 'improve-spawn-priority',
              description: 'ã‚¹ãƒãƒ¼ãƒ³å„ªå…ˆåº¦ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ”¹å–„',
              apply: () => {
                const main = fs.readFileSync('main.js', 'utf8');
                if (main.includes('spawnPriority')) return false;
                
                const code = \`
    // Smart Spawn Priority (Auto-added)
    if (!Memory.spawnPriority) {
        Memory.spawnPriority = ['harvester', 'upgrader', 'builder', 'repairer'];
    }
    // Auto-adjust priority based on current needs
    if (Game.time % 500 === 0) {
        const counts = {};
        Object.values(Game.creeps).forEach(c => {
            counts[c.memory.role] = (counts[c.memory.role] || 0) + 1;
        });
        Memory.spawnPriority.sort((a, b) => (counts[a] || 0) - (counts[b] || 0));
    }
\`;
                const updated = main.replace(/(module\.exports\.loop\s*=\s*function\s*\(\s*\)\s*{)/, \`\$1\${code}\`);
                fs.writeFileSync('main.js', updated);
                return true;
              }
            },
            {
              name: 'add-tower-optimization',
              description: 'ã‚¿ãƒ¯ãƒ¼ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠžã‚’æœ€é©åŒ–',
              apply: () => {
                const main = fs.readFileSync('main.js', 'utf8');
                if (main.includes('towerTargeting')) return false;
                
                const code = \`
    // Smart Tower Targeting (Auto-added)
    const towers = Object.values(Game.structures).filter(s => s.structureType === STRUCTURE_TOWER);
    towers.forEach(tower => {
        const hostiles = tower.room.find(FIND_HOSTILE_CREEPS);
        if (hostiles.length > 0) {
            // Target closest or strongest enemy
            const target = hostiles.sort((a, b) => {
                const distA = tower.pos.getRangeTo(a);
                const distB = tower.pos.getRangeTo(b);
                return distA === distB ? b.hits - a.hits : distA - distB;
            })[0];
            tower.attack(target);
        } else {
            // Repair damaged structures
            const damaged = tower.room.find(FIND_STRUCTURES, {
                filter: s => s.hits < s.hitsMax * 0.8
            });
            if (damaged.length > 0) {
                tower.repair(damaged[0]);
            }
        }
    });
\`;
                const updated = main.replace(/(module\.exports\.loop\s*=\s*function\s*\(\s*\)\s*{)/, \`\$1\${code}\`);
                fs.writeFileSync('main.js', updated);
                return true;
              }
            },
            {
              name: 'add-energy-efficiency',
              description: 'ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹çŽ‡ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°',
              apply: () => {
                const main = fs.readFileSync('main.js', 'utf8');
                if (main.includes('energyEfficiency')) return false;
                
                const code = \`
    // Energy Efficiency Tracking (Auto-added)
    if (Game.time % 1000 === 0) {
        const rooms = Object.values(Game.rooms).filter(r => r.controller && r.controller.my);
        rooms.forEach(room => {
            const stored = room.energyAvailable;
            const capacity = room.energyCapacityAvailable;
            const efficiency = capacity > 0 ? (stored / capacity * 100).toFixed(1) : 0;
            console.log(\\\`âš¡ Room \\\${room.name}: \\\${efficiency}% energy efficiency\\\`);
        });
    }
\`;
                const updated = main.replace(/(module\.exports\.loop\s*=\s*function\s*\(\s*\)\s*{)/, \`\$1\${code}\`);
                fs.writeFileSync('main.js', updated);
                return true;
              }
            }
          ];
          
          // ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸æŠž
          const selected = experiments[Math.floor(Math.random() * experiments.length)];
          console.log(\`ðŸŽ² Selected experiment: \${selected.name}\`);
          console.log(\`ðŸ“ Description: \${selected.description}\`);
          
          const success = selected.apply();
          
          if (success) {
            const report = {
              experiment: selected.name,
              description: selected.description,
              timestamp: new Date().toISOString(),
              status: 'applied'
            };
            fs.writeFileSync('last-experiment.json', JSON.stringify(report, null, 2));
            console.log('âœ… Experiment applied successfully!');
          } else {
            console.log('âš ï¸ Experiment already exists or not applicable');
            process.exit(1);
          }
          "
      
      - name: Commit experiment
        run: |
          git config user.name 'Experiment Bot'
          git config user.email 'experiment@screeps.local'
          git add *.js last-experiment.json
          
          if ! git diff --staged --quiet; then
            EXPERIMENT=$(node -e "console.log(require('./last-experiment.json').description)" 2>/dev/null || echo "code improvement")
            git commit -m "ðŸŽ² Random experiment: ${EXPERIMENT}
            
            This is an experimental feature that may improve performance.
            Monitor the results and revert if needed."
            git push
          else
            echo "No changes to commit"
          fi
