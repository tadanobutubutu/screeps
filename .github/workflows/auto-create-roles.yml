name: ðŸ†• Auto Create New Roles

on:
  schedule:
    # Every Monday at 3 AM JST (Sunday 6 PM UTC)
    - cron: '0 18 * * 0'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  create-new-role:
    runs-on: ubuntu-latest
    name: Generate New Role Files
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Create new role file
        run: |
          node -e "
          const fs = require('fs');
          
          // ä½œæˆå¯èƒ½ãªãƒ­ãƒ¼ãƒ«ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
          const roleTemplates = [
            {
              name: 'defender',
              description: 'éƒ¨å±‹ã‚’é˜²è¡›ã™ã‚‹æˆ¦é—˜ã‚¯ãƒªãƒ¼ãƒ—',
              body: \`const roleDefender = {
    run: function(creep) {
        // æ•µã‚’æŽ¢ã™
        const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);
        
        if (hostiles.length > 0) {
            // æœ€ã‚‚è¿‘ã„æ•µã‚’æ”»æ’ƒ
            const target = creep.pos.findClosestByRange(hostiles);
            if (creep.attack(target) === ERR_NOT_IN_RANGE) {
                creep.moveTo(target, {visualizePathStyle: {stroke: '#ff0000'}});
            }
        } else {
            // æ•µãŒã„ãªã„å ´åˆã¯éƒ¨å±‹ã®ä¸­å¿ƒä»˜è¿‘ã§å¾…æ©Ÿ
            const flag = Game.flags['DefensePoint'];
            if (flag) {
                creep.moveTo(flag);
            } else {
                creep.moveTo(25, 25);
            }
        }
    }
};

module.exports = roleDefender;\`
            },
            {
              name: 'miner',
              description: 'ã‚½ãƒ¼ã‚¹ã®éš£ã«å›ºå®šã—ã¦æŽ¡æŽ˜ã™ã‚‹åŠ¹çŽ‡çš„ãªãƒãƒ¼ãƒ™ã‚¹ã‚¿ãƒ¼',
              body: \`const roleMiner = {
    run: function(creep) {
        // æ‹…å½“ã‚½ãƒ¼ã‚¹ãŒæœªè¨­å®šãªã‚‰å‰²ã‚Šå½“ã¦
        if (!creep.memory.sourceId) {
            const sources = creep.room.find(FIND_SOURCES);
            creep.memory.sourceId = sources[0].id;
        }
        
        const source = Game.getObjectById(creep.memory.sourceId);
        if (!source) return;
        
        // ã‚½ãƒ¼ã‚¹ã®éš£ã«ç§»å‹•
        if (!creep.pos.isNearTo(source)) {
            creep.moveTo(source, {visualizePathStyle: {stroke: '#ffaa00'}});
        } else {
            // æŽ¡æŽ˜
            creep.harvest(source);
            
            // éš£ã«ã‚³ãƒ³ãƒ†ãƒŠãŒã‚ã‚Œã°ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è»¢é€
            const container = creep.pos.findInRange(FIND_STRUCTURES, 1, {
                filter: s => s.structureType === STRUCTURE_CONTAINER
            })[0];
            
            if (container && creep.store.getFreeCapacity() === 0) {
                creep.transfer(container, RESOURCE_ENERGY);
            }
        }
    }
};

module.exports = roleMiner;\`
            },
            {
              name: 'claimer',
              description: 'æ–°ã—ã„éƒ¨å±‹ã‚’ã‚¯ãƒ¬ãƒ¼ãƒ ã—ã¦é ˜åœŸã‚’æ‹¡å¤§',
              body: \`const roleClaimer = {
    run: function(creep) {
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ«ãƒ¼ãƒ ãŒæœªè¨­å®šãªã‚‰çµ‚äº†
        if (!creep.memory.targetRoom) {
            console.log('Claimer needs targetRoom in memory!');
            return;
        }
        
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã«ç§»å‹•
        if (creep.room.name !== creep.memory.targetRoom) {
            const exit = creep.room.findExitTo(creep.memory.targetRoom);
            const exitPos = creep.pos.findClosestByRange(exit);
            creep.moveTo(exitPos, {visualizePathStyle: {stroke: '#00ff00'}});
        } else {
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ã‚¯ãƒ¬ãƒ¼ãƒ 
            const controller = creep.room.controller;
            if (controller) {
                if (creep.claimController(controller) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(controller, {visualizePathStyle: {stroke: '#00ff00'}});
                }
            }
        }
    }
};

module.exports = roleClaimer;\`
            },
            {
              name: 'remoteHarvester',
              description: 'éš£ã®éƒ¨å±‹ã‹ã‚‰ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æŒã¡å¸°ã‚‹',
              body: \`const roleRemoteHarvester = {
    run: function(creep) {
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ«ãƒ¼ãƒ ãŒæœªè¨­å®šãªã‚‰çµ‚äº†
        if (!creep.memory.targetRoom) {
            console.log('RemoteHarvester needs targetRoom in memory!');
            return;
        }
        
        if (creep.store.getFreeCapacity() > 0) {
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã¸ç§»å‹•ã—ã¦æŽ¡æŽ˜
            if (creep.room.name !== creep.memory.targetRoom) {
                const exit = creep.room.findExitTo(creep.memory.targetRoom);
                const exitPos = creep.pos.findClosestByRange(exit);
                creep.moveTo(exitPos, {visualizePathStyle: {stroke: '#ffff00'}});
            } else {
                const source = creep.pos.findClosestByPath(FIND_SOURCES);
                if (creep.harvest(source) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(source, {visualizePathStyle: {stroke: '#ffff00'}});
                }
            }
        } else {
            // ãƒ›ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ ã«æˆ»ã£ã¦ã‚¹ãƒãƒ¼ãƒ³ã«è»¢é€
            if (creep.room.name !== creep.memory.homeRoom) {
                const exit = creep.room.findExitTo(creep.memory.homeRoom);
                const exitPos = creep.pos.findClosestByRange(exit);
                creep.moveTo(exitPos, {visualizePathStyle: {stroke: '#ffffff'}});
            } else {
                const spawn = creep.pos.findClosestByPath(FIND_MY_SPAWNS);
                if (creep.transfer(spawn, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(spawn, {visualizePathStyle: {stroke: '#ffffff'}});
                }
            }
        }
    }
};

module.exports = roleRemoteHarvester;\`
            },
            {
              name: 'healer',
              description: 'å‚·ã¤ã„ãŸã‚¯ãƒªãƒ¼ãƒ—ã‚’å›žå¾©ã™ã‚‹',
              body: \`const roleHealer = {
    run: function(creep) {
        // å‚·ã¤ã„ãŸå‘³æ–¹ã‚¯ãƒªãƒ¼ãƒ—ã‚’æŽ¢ã™
        const damagedCreep = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
            filter: c => c.hits < c.hitsMax
        });
        
        if (damagedCreep) {
            // å›žå¾©
            if (creep.heal(damagedCreep) === ERR_NOT_IN_RANGE) {
                creep.moveTo(damagedCreep, {visualizePathStyle: {stroke: '#00ff00'}});
                // ç§»å‹•ä¸­ã‚‚é éš”å›žå¾©
                creep.rangedHeal(damagedCreep);
            }
        } else {
            // å‚·ã¤ã„ãŸã‚¯ãƒªãƒ¼ãƒ—ãŒã„ãªã„å ´åˆã¯é˜²è¡›ãƒã‚¤ãƒ³ãƒˆã¸
            const flag = Game.flags['HealPoint'];
            if (flag) {
                creep.moveTo(flag);
            } else {
                // æˆ¦é—˜ã‚¯ãƒªãƒ¼ãƒ—ã®è¿‘ãã«å¾…æ©Ÿ
                const defender = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
                    filter: c => c.memory.role === 'defender'
                });
                if (defender) {
                    creep.moveTo(defender);
                }
            }
        }
    }
};

module.exports = roleHealer;\`
            },
            {
              name: 'scout',
              description: 'å‘¨è¾ºã®éƒ¨å±‹ã‚’æŽ¢ç´¢ã—ã¦ãƒžãƒƒãƒ—ã™ã‚‹ï¼ˆæ”¹è‰¯ç‰ˆï¼‰',
              body: \`const roleScout = {
    run: function(creep) {
        // æŽ¢ç´¢æ¸ˆã¿éƒ¨å±‹ãƒªã‚¹ãƒˆã‚’åˆæœŸåŒ–
        if (!Memory.scoutedRooms) {
            Memory.scoutedRooms = {};
        }
        
        // ç¾åœ¨ã®éƒ¨å±‹ã‚’è¨˜éŒ²
        const room = creep.room;
        if (!Memory.scoutedRooms[room.name]) {
            Memory.scoutedRooms[room.name] = {
                timestamp: Game.time,
                sources: room.find(FIND_SOURCES).length,
                controller: room.controller ? {
                    level: room.controller.level,
                    owner: room.controller.owner ? room.controller.owner.username : null,
                    reservation: room.controller.reservation ? room.controller.reservation.username : null
                } : null,
                hostiles: room.find(FIND_HOSTILE_CREEPS).length
            };
            console.log(\`ðŸ“ Scout mapped: \${room.name}\`);
        }
        
        // æ¬¡ã®æŽ¢ç´¢å…ˆã‚’æ±ºå®š
        if (!creep.memory.targetRoom) {
            const exits = Game.map.describeExits(room.name);
            const unscoutedExits = Object.entries(exits).filter(
                ([dir, roomName]) => !Memory.scoutedRooms[roomName]
            );
            
            if (unscoutedExits.length > 0) {
                const [dir, targetRoom] = unscoutedExits[0];
                creep.memory.targetRoom = targetRoom;
            } else {
                // å…¨éƒ¨å±‹æŽ¢ç´¢æ¸ˆã¿ãªã‚‰æœ€ã‚‚å¤ã„è¨˜éŒ²ã®éƒ¨å±‹ã¸
                const oldestRoom = Object.entries(Memory.scoutedRooms)
                    .sort((a, b) => a[1].timestamp - b[1].timestamp)[0];
                if (oldestRoom) {
                    creep.memory.targetRoom = oldestRoom[0];
                }
            }
        }
        
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆéƒ¨å±‹ã¸ç§»å‹•
        if (creep.memory.targetRoom && room.name !== creep.memory.targetRoom) {
            const exit = room.findExitTo(creep.memory.targetRoom);
            const exitPos = creep.pos.findClosestByRange(exit);
            if (exitPos) {
                creep.moveTo(exitPos, {visualizePathStyle: {stroke: '#00ffff'}});
            }
        } else {
            // åˆ°ç€ã—ãŸã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢
            delete creep.memory.targetRoom;
        }
    }
};

module.exports = roleScout;\`
            },
            {
              name: 'powerHarvester',
              description: 'Power Bankã‚’æ”»æ’ƒã—ã¦ãƒ‘ãƒ¯ãƒ¼ã‚’å›žåŽ',
              body: \`const rolePowerHarvester = {
    run: function(creep) {
        // Power Bankã®ã‚ã‚‹éƒ¨å±‹ãŒæœªè¨­å®šãªã‚‰æŽ¢ã™
        if (!creep.memory.powerBankRoom) {
            // ãƒ¡ãƒ¢ãƒªã«è¨˜éŒ²ã•ã‚ŒãŸPower Bankæƒ…å ±ã‚’ãƒã‚§ãƒƒã‚¯
            if (Memory.powerBanks && Memory.powerBanks.length > 0) {
                const nearest = Memory.powerBanks[0];
                creep.memory.powerBankRoom = nearest.room;
                creep.memory.powerBankId = nearest.id;
            } else {
                console.log('No Power Banks found in memory');
                return;
            }
        }
        
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆéƒ¨å±‹ã«ç§»å‹•
        if (creep.room.name !== creep.memory.powerBankRoom) {
            const exit = creep.room.findExitTo(creep.memory.powerBankRoom);
            const exitPos = creep.pos.findClosestByRange(exit);
            creep.moveTo(exitPos, {visualizePathStyle: {stroke: '#ff00ff'}});
        } else {
            // Power Bankã‚’æ”»æ’ƒ
            const powerBank = Game.getObjectById(creep.memory.powerBankId);
            if (powerBank) {
                if (creep.attack(powerBank) === ERR_NOT_IN_RANGE) {
                    creep.moveTo(powerBank, {visualizePathStyle: {stroke: '#ff00ff'}});
                }
            } else {
                // Power BankãŒç ´å£Šã•ã‚ŒãŸã‚‰ãƒ‘ãƒ¯ãƒ¼ã‚’æ‹¾ã†
                const power = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {
                    filter: r => r.resourceType === RESOURCE_POWER
                });
                if (power) {
                    if (creep.pickup(power) === ERR_NOT_IN_RANGE) {
                        creep.moveTo(power);
                    }
                } else {
                    // ã‚¿ã‚¹ã‚¯å®Œäº†
                    delete creep.memory.powerBankRoom;
                    delete creep.memory.powerBankId;
                }
            }
        }
    }
};

module.exports = rolePowerHarvester;\`
            }
          ];
          
          // æ—¢å­˜ã®ãƒ­ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèª
          const existingRoles = fs.readdirSync('.')
            .filter(f => f.startsWith('role.') && f.endsWith('.js'))
            .map(f => f.replace('role.', '').replace('.js', ''));
          
          console.log('ðŸ“‹ Existing roles:', existingRoles.join(', '));
          
          // ã¾ã ä½œæˆã•ã‚Œã¦ã„ãªã„ãƒ­ãƒ¼ãƒ«ã‚’æŽ¢ã™
          const availableTemplates = roleTemplates.filter(
            t => !existingRoles.includes(t.name)
          );
          
          if (availableTemplates.length === 0) {
            console.log('âœ… All role templates already exist!');
            process.exit(1);
          }
          
          // ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸æŠž
          const selected = availableTemplates[Math.floor(Math.random() * availableTemplates.length)];
          
          console.log(\`ðŸ†• Creating new role: \${selected.name}\`);
          console.log(\`ðŸ“ Description: \${selected.description}\`);
          
          // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
          const filename = \`role.\${selected.name}.js\`;
          fs.writeFileSync(filename, selected.body);
          
          // ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
          const report = {
            role: selected.name,
            description: selected.description,
            filename: filename,
            timestamp: new Date().toISOString(),
            remaining: availableTemplates.length - 1
          };
          fs.writeFileSync('last-role-creation.json', JSON.stringify(report, null, 2));
          
          console.log(\`âœ… Created: \${filename}\`);
          console.log(\`ðŸ“Š Remaining templates: \${report.remaining}\`);
          "
      
      - name: Update main.js to include new role
        run: |
          node -e "
          const fs = require('fs');
          
          if (!fs.existsSync('last-role-creation.json')) {
            console.log('No new role created');
            process.exit(0);
          }
          
          const report = JSON.parse(fs.readFileSync('last-role-creation.json', 'utf8'));
          const roleName = report.role;
          const main = fs.readFileSync('main.js', 'utf8');
          
          // æ—¢ã«requireãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          const requireLine = \`const role\${roleName.charAt(0).toUpperCase() + roleName.slice(1)} = require('role.\${roleName}');\`;
          
          if (main.includes(requireLine)) {
            console.log('Role already imported in main.js');
          } else {
            // main.jsã®å…ˆé ­ã«requireã‚’è¿½åŠ 
            const lines = main.split('\\n');
            const lastRequireIndex = lines.findIndex(line => line.includes('require') && line.includes('role.'));
            
            if (lastRequireIndex >= 0) {
              lines.splice(lastRequireIndex + 1, 0, requireLine);
            } else {
              lines.unshift(requireLine);
            }
            
            fs.writeFileSync('main.js', lines.join('\\n'));
            console.log(\`âœ… Added \${roleName} import to main.js\`);
          }
          "
      
      - name: Commit new role
        run: |
          git config user.name 'Role Creator Bot'
          git config user.email 'role-creator@screeps.local'
          git add role.*.js main.js last-role-creation.json
          
          if ! git diff --staged --quiet; then
            ROLE_NAME=$(node -e "console.log(require('./last-role-creation.json').role)" 2>/dev/null || echo "new role")
            DESCRIPTION=$(node -e "console.log(require('./last-role-creation.json').description)" 2>/dev/null || echo "")
            git commit -m "ðŸ†• Auto-created role: ${ROLE_NAME}
            
            ${DESCRIPTION}
            
            This role was automatically generated and added to the codebase."
            git push
          else
            echo "No changes to commit"
          fi
